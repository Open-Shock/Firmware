// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEVICETOLOCALMESSAGE_OPENSHOCK_SERIALIZATION_LOCAL_H_
#define FLATBUFFERS_GENERATED_DEVICETOLOCALMESSAGE_OPENSHOCK_SERIALIZATION_LOCAL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "WifiAuthMode_generated.h"
#include "WifiScanStatus_generated.h"

namespace OpenShock {
namespace Serialization {
namespace Local {

struct WifiNetwork;
struct WifiNetworkBuilder;

struct ReadyMessage;
struct ReadyMessageBuilder;

struct ErrorMessage;
struct ErrorMessageBuilder;

struct WifiScanStatusMessage;

struct WifiNetworkDiscoveredEvent;
struct WifiNetworkDiscoveredEventBuilder;

struct WifiNetworkUpdatedEvent;
struct WifiNetworkUpdatedEventBuilder;

struct WifiNetworkLostEvent;
struct WifiNetworkLostEventBuilder;

struct WifiNetworkSavedEvent;
struct WifiNetworkSavedEventBuilder;

struct WifiNetworkRemovedEvent;
struct WifiNetworkRemovedEventBuilder;

struct WifiNetworkConnectedEvent;
struct WifiNetworkConnectedEventBuilder;

struct WifiNetworkDisconnectedEvent;
struct WifiNetworkDisconnectedEventBuilder;

struct GatewayPairCommandResult;

struct SetRfTxPinCommandResult;

struct DeviceToLocalMessage;
struct DeviceToLocalMessageBuilder;

enum class GatewayPairResultCode : uint8_t {
  Success = 0,
  CodeRequired = 1,
  InvalidCodeLength = 2,
  NoInternetConnection = 3,
  InvalidCode = 4,
  InternalError = 5,
  MIN = Success,
  MAX = InternalError
};

inline const GatewayPairResultCode (&EnumValuesGatewayPairResultCode())[6] {
  static const GatewayPairResultCode values[] = {
    GatewayPairResultCode::Success,
    GatewayPairResultCode::CodeRequired,
    GatewayPairResultCode::InvalidCodeLength,
    GatewayPairResultCode::NoInternetConnection,
    GatewayPairResultCode::InvalidCode,
    GatewayPairResultCode::InternalError
  };
  return values;
}

inline const char * const *EnumNamesGatewayPairResultCode() {
  static const char * const names[7] = {
    "Success",
    "CodeRequired",
    "InvalidCodeLength",
    "NoInternetConnection",
    "InvalidCode",
    "InternalError",
    nullptr
  };
  return names;
}

inline const char *EnumNameGatewayPairResultCode(GatewayPairResultCode e) {
  if (::flatbuffers::IsOutRange(e, GatewayPairResultCode::Success, GatewayPairResultCode::InternalError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGatewayPairResultCode()[index];
}

enum class SetRfPinResultCode : uint8_t {
  Success = 0,
  InvalidPin = 1,
  InternalError = 2,
  MIN = Success,
  MAX = InternalError
};

inline const SetRfPinResultCode (&EnumValuesSetRfPinResultCode())[3] {
  static const SetRfPinResultCode values[] = {
    SetRfPinResultCode::Success,
    SetRfPinResultCode::InvalidPin,
    SetRfPinResultCode::InternalError
  };
  return values;
}

inline const char * const *EnumNamesSetRfPinResultCode() {
  static const char * const names[4] = {
    "Success",
    "InvalidPin",
    "InternalError",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetRfPinResultCode(SetRfPinResultCode e) {
  if (::flatbuffers::IsOutRange(e, SetRfPinResultCode::Success, SetRfPinResultCode::InternalError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetRfPinResultCode()[index];
}

enum class DeviceToLocalMessagePayload : uint8_t {
  NONE = 0,
  ReadyMessage = 1,
  ErrorMessage = 2,
  WifiScanStatusMessage = 3,
  WifiNetworkDiscoveredEvent = 4,
  WifiNetworkUpdatedEvent = 5,
  WifiNetworkLostEvent = 6,
  WifiNetworkSavedEvent = 7,
  WifiNetworkRemovedEvent = 8,
  WifiNetworkConnectedEvent = 9,
  WifiNetworkDisconnectedEvent = 10,
  GatewayPairCommandResult = 11,
  SetRfTxPinCommandResult = 12,
  MIN = NONE,
  MAX = SetRfTxPinCommandResult
};

inline const DeviceToLocalMessagePayload (&EnumValuesDeviceToLocalMessagePayload())[13] {
  static const DeviceToLocalMessagePayload values[] = {
    DeviceToLocalMessagePayload::NONE,
    DeviceToLocalMessagePayload::ReadyMessage,
    DeviceToLocalMessagePayload::ErrorMessage,
    DeviceToLocalMessagePayload::WifiScanStatusMessage,
    DeviceToLocalMessagePayload::WifiNetworkDiscoveredEvent,
    DeviceToLocalMessagePayload::WifiNetworkUpdatedEvent,
    DeviceToLocalMessagePayload::WifiNetworkLostEvent,
    DeviceToLocalMessagePayload::WifiNetworkSavedEvent,
    DeviceToLocalMessagePayload::WifiNetworkRemovedEvent,
    DeviceToLocalMessagePayload::WifiNetworkConnectedEvent,
    DeviceToLocalMessagePayload::WifiNetworkDisconnectedEvent,
    DeviceToLocalMessagePayload::GatewayPairCommandResult,
    DeviceToLocalMessagePayload::SetRfTxPinCommandResult
  };
  return values;
}

inline const char * const *EnumNamesDeviceToLocalMessagePayload() {
  static const char * const names[14] = {
    "NONE",
    "ReadyMessage",
    "ErrorMessage",
    "WifiScanStatusMessage",
    "WifiNetworkDiscoveredEvent",
    "WifiNetworkUpdatedEvent",
    "WifiNetworkLostEvent",
    "WifiNetworkSavedEvent",
    "WifiNetworkRemovedEvent",
    "WifiNetworkConnectedEvent",
    "WifiNetworkDisconnectedEvent",
    "GatewayPairCommandResult",
    "SetRfTxPinCommandResult",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceToLocalMessagePayload(DeviceToLocalMessagePayload e) {
  if (::flatbuffers::IsOutRange(e, DeviceToLocalMessagePayload::NONE, DeviceToLocalMessagePayload::SetRfTxPinCommandResult)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceToLocalMessagePayload()[index];
}

template<typename T> struct DeviceToLocalMessagePayloadTraits {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::NONE;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::ReadyMessage> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::ReadyMessage;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::ErrorMessage> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::ErrorMessage;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiScanStatusMessage> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiScanStatusMessage;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkDiscoveredEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkDiscoveredEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkUpdatedEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkUpdatedEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkLostEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkLostEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkSavedEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkSavedEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkRemovedEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkRemovedEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkConnectedEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkConnectedEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkDisconnectedEvent> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::WifiNetworkDisconnectedEvent;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::GatewayPairCommandResult> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::GatewayPairCommandResult;
};

template<> struct DeviceToLocalMessagePayloadTraits<OpenShock::Serialization::Local::SetRfTxPinCommandResult> {
  static const DeviceToLocalMessagePayload enum_value = DeviceToLocalMessagePayload::SetRfTxPinCommandResult;
};

bool VerifyDeviceToLocalMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, DeviceToLocalMessagePayload type);
bool VerifyDeviceToLocalMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<DeviceToLocalMessagePayload> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) WifiScanStatusMessage FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t status_;

 public:
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiScanStatusMessage";
  }
  WifiScanStatusMessage()
      : status_(0) {
  }
  WifiScanStatusMessage(OpenShock::Serialization::Types::WifiScanStatus _status)
      : status_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_status))) {
  }
  OpenShock::Serialization::Types::WifiScanStatus status() const {
    return static_cast<OpenShock::Serialization::Types::WifiScanStatus>(::flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(WifiScanStatusMessage, 1);

struct WifiScanStatusMessage::Traits {
  using type = WifiScanStatusMessage;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) GatewayPairCommandResult FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t result_;

 public:
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.GatewayPairCommandResult";
  }
  GatewayPairCommandResult()
      : result_(0) {
  }
  GatewayPairCommandResult(OpenShock::Serialization::Local::GatewayPairResultCode _result)
      : result_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_result))) {
  }
  OpenShock::Serialization::Local::GatewayPairResultCode result() const {
    return static_cast<OpenShock::Serialization::Local::GatewayPairResultCode>(::flatbuffers::EndianScalar(result_));
  }
};
FLATBUFFERS_STRUCT_END(GatewayPairCommandResult, 1);

struct GatewayPairCommandResult::Traits {
  using type = GatewayPairCommandResult;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) SetRfTxPinCommandResult FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pin_;
  uint8_t result_;

 public:
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.SetRfTxPinCommandResult";
  }
  SetRfTxPinCommandResult()
      : pin_(0),
        result_(0) {
  }
  SetRfTxPinCommandResult(uint8_t _pin, OpenShock::Serialization::Local::SetRfPinResultCode _result)
      : pin_(::flatbuffers::EndianScalar(_pin)),
        result_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_result))) {
  }
  uint8_t pin() const {
    return ::flatbuffers::EndianScalar(pin_);
  }
  OpenShock::Serialization::Local::SetRfPinResultCode result() const {
    return static_cast<OpenShock::Serialization::Local::SetRfPinResultCode>(::flatbuffers::EndianScalar(result_));
  }
};
FLATBUFFERS_STRUCT_END(SetRfTxPinCommandResult, 2);

struct SetRfTxPinCommandResult::Traits {
  using type = SetRfTxPinCommandResult;
};

struct WifiNetwork FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetwork";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_BSSID = 6,
    VT_CHANNEL = 8,
    VT_RSSI = 10,
    VT_AUTH_MODE = 12,
    VT_SAVED = 14
  };
  const ::flatbuffers::String *ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID);
  }
  const ::flatbuffers::String *bssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BSSID);
  }
  uint8_t channel() const {
    return GetField<uint8_t>(VT_CHANNEL, 0);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  OpenShock::Serialization::Types::WifiAuthMode auth_mode() const {
    return static_cast<OpenShock::Serialization::Types::WifiAuthMode>(GetField<uint8_t>(VT_AUTH_MODE, 0));
  }
  bool saved() const {
    return GetField<uint8_t>(VT_SAVED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_BSSID) &&
           verifier.VerifyString(bssid()) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL, 1) &&
           VerifyField<int8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_AUTH_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SAVED, 1) &&
           verifier.EndTable();
  }
};

struct WifiNetworkBuilder {
  typedef WifiNetwork Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssid(::flatbuffers::Offset<::flatbuffers::String> ssid) {
    fbb_.AddOffset(WifiNetwork::VT_SSID, ssid);
  }
  void add_bssid(::flatbuffers::Offset<::flatbuffers::String> bssid) {
    fbb_.AddOffset(WifiNetwork::VT_BSSID, bssid);
  }
  void add_channel(uint8_t channel) {
    fbb_.AddElement<uint8_t>(WifiNetwork::VT_CHANNEL, channel, 0);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(WifiNetwork::VT_RSSI, rssi, 0);
  }
  void add_auth_mode(OpenShock::Serialization::Types::WifiAuthMode auth_mode) {
    fbb_.AddElement<uint8_t>(WifiNetwork::VT_AUTH_MODE, static_cast<uint8_t>(auth_mode), 0);
  }
  void add_saved(bool saved) {
    fbb_.AddElement<uint8_t>(WifiNetwork::VT_SAVED, static_cast<uint8_t>(saved), 0);
  }
  explicit WifiNetworkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetwork> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetwork>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetwork> CreateWifiNetwork(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ssid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> bssid = 0,
    uint8_t channel = 0,
    int8_t rssi = 0,
    OpenShock::Serialization::Types::WifiAuthMode auth_mode = OpenShock::Serialization::Types::WifiAuthMode::Open,
    bool saved = false) {
  WifiNetworkBuilder builder_(_fbb);
  builder_.add_bssid(bssid);
  builder_.add_ssid(ssid);
  builder_.add_saved(saved);
  builder_.add_auth_mode(auth_mode);
  builder_.add_rssi(rssi);
  builder_.add_channel(channel);
  return builder_.Finish();
}

struct WifiNetwork::Traits {
  using type = WifiNetwork;
  static auto constexpr Create = CreateWifiNetwork;
};

inline ::flatbuffers::Offset<WifiNetwork> CreateWifiNetworkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *bssid = nullptr,
    uint8_t channel = 0,
    int8_t rssi = 0,
    OpenShock::Serialization::Types::WifiAuthMode auth_mode = OpenShock::Serialization::Types::WifiAuthMode::Open,
    bool saved = false) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto bssid__ = bssid ? _fbb.CreateString(bssid) : 0;
  return OpenShock::Serialization::Local::CreateWifiNetwork(
      _fbb,
      ssid__,
      bssid__,
      channel,
      rssi,
      auth_mode,
      saved);
}

struct ReadyMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadyMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.ReadyMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POGGIES = 4,
    VT_CONNECTED_WIFI = 6,
    VT_GATEWAY_PAIRED = 8,
    VT_RFTX_PIN = 10
  };
  bool poggies() const {
    return GetField<uint8_t>(VT_POGGIES, 0) != 0;
  }
  const OpenShock::Serialization::Local::WifiNetwork *connected_wifi() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_CONNECTED_WIFI);
  }
  bool gateway_paired() const {
    return GetField<uint8_t>(VT_GATEWAY_PAIRED, 0) != 0;
  }
  uint8_t rftx_pin() const {
    return GetField<uint8_t>(VT_RFTX_PIN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POGGIES, 1) &&
           VerifyOffset(verifier, VT_CONNECTED_WIFI) &&
           verifier.VerifyTable(connected_wifi()) &&
           VerifyField<uint8_t>(verifier, VT_GATEWAY_PAIRED, 1) &&
           VerifyField<uint8_t>(verifier, VT_RFTX_PIN, 1) &&
           verifier.EndTable();
  }
};

struct ReadyMessageBuilder {
  typedef ReadyMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_poggies(bool poggies) {
    fbb_.AddElement<uint8_t>(ReadyMessage::VT_POGGIES, static_cast<uint8_t>(poggies), 0);
  }
  void add_connected_wifi(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> connected_wifi) {
    fbb_.AddOffset(ReadyMessage::VT_CONNECTED_WIFI, connected_wifi);
  }
  void add_gateway_paired(bool gateway_paired) {
    fbb_.AddElement<uint8_t>(ReadyMessage::VT_GATEWAY_PAIRED, static_cast<uint8_t>(gateway_paired), 0);
  }
  void add_rftx_pin(uint8_t rftx_pin) {
    fbb_.AddElement<uint8_t>(ReadyMessage::VT_RFTX_PIN, rftx_pin, 0);
  }
  explicit ReadyMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadyMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadyMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadyMessage> CreateReadyMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool poggies = false,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> connected_wifi = 0,
    bool gateway_paired = false,
    uint8_t rftx_pin = 0) {
  ReadyMessageBuilder builder_(_fbb);
  builder_.add_connected_wifi(connected_wifi);
  builder_.add_rftx_pin(rftx_pin);
  builder_.add_gateway_paired(gateway_paired);
  builder_.add_poggies(poggies);
  return builder_.Finish();
}

struct ReadyMessage::Traits {
  using type = ReadyMessage;
  static auto constexpr Create = CreateReadyMessage;
};

struct ErrorMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.ErrorMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ErrorMessageBuilder {
  typedef ErrorMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ErrorMessage::VT_MESSAGE, message);
  }
  explicit ErrorMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorMessage> CreateErrorMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ErrorMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

struct ErrorMessage::Traits {
  using type = ErrorMessage;
  static auto constexpr Create = CreateErrorMessage;
};

inline ::flatbuffers::Offset<ErrorMessage> CreateErrorMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return OpenShock::Serialization::Local::CreateErrorMessage(
      _fbb,
      message__);
}

struct WifiNetworkDiscoveredEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkDiscoveredEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkDiscoveredEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkDiscoveredEventBuilder {
  typedef WifiNetworkDiscoveredEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkDiscoveredEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkDiscoveredEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkDiscoveredEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkDiscoveredEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkDiscoveredEvent> CreateWifiNetworkDiscoveredEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkDiscoveredEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkDiscoveredEvent::Traits {
  using type = WifiNetworkDiscoveredEvent;
  static auto constexpr Create = CreateWifiNetworkDiscoveredEvent;
};

struct WifiNetworkUpdatedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkUpdatedEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkUpdatedEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkUpdatedEventBuilder {
  typedef WifiNetworkUpdatedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkUpdatedEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkUpdatedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkUpdatedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkUpdatedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkUpdatedEvent> CreateWifiNetworkUpdatedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkUpdatedEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkUpdatedEvent::Traits {
  using type = WifiNetworkUpdatedEvent;
  static auto constexpr Create = CreateWifiNetworkUpdatedEvent;
};

struct WifiNetworkLostEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkLostEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkLostEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkLostEventBuilder {
  typedef WifiNetworkLostEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkLostEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkLostEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkLostEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkLostEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkLostEvent> CreateWifiNetworkLostEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkLostEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkLostEvent::Traits {
  using type = WifiNetworkLostEvent;
  static auto constexpr Create = CreateWifiNetworkLostEvent;
};

struct WifiNetworkSavedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkSavedEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkSavedEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkSavedEventBuilder {
  typedef WifiNetworkSavedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkSavedEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkSavedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkSavedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkSavedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkSavedEvent> CreateWifiNetworkSavedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkSavedEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkSavedEvent::Traits {
  using type = WifiNetworkSavedEvent;
  static auto constexpr Create = CreateWifiNetworkSavedEvent;
};

struct WifiNetworkRemovedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkRemovedEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkRemovedEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkRemovedEventBuilder {
  typedef WifiNetworkRemovedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkRemovedEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkRemovedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkRemovedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkRemovedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkRemovedEvent> CreateWifiNetworkRemovedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkRemovedEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkRemovedEvent::Traits {
  using type = WifiNetworkRemovedEvent;
  static auto constexpr Create = CreateWifiNetworkRemovedEvent;
};

struct WifiNetworkConnectedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkConnectedEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkConnectedEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkConnectedEventBuilder {
  typedef WifiNetworkConnectedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkConnectedEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkConnectedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkConnectedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkConnectedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkConnectedEvent> CreateWifiNetworkConnectedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkConnectedEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkConnectedEvent::Traits {
  using type = WifiNetworkConnectedEvent;
  static auto constexpr Create = CreateWifiNetworkConnectedEvent;
};

struct WifiNetworkDisconnectedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkDisconnectedEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkDisconnectedEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NETWORK = 4
  };
  const OpenShock::Serialization::Local::WifiNetwork *network() const {
    return GetPointer<const OpenShock::Serialization::Local::WifiNetwork *>(VT_NETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkDisconnectedEventBuilder {
  typedef WifiNetworkDisconnectedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_network(::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network) {
    fbb_.AddOffset(WifiNetworkDisconnectedEvent::VT_NETWORK, network);
  }
  explicit WifiNetworkDisconnectedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkDisconnectedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkDisconnectedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkDisconnectedEvent> CreateWifiNetworkDisconnectedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::WifiNetwork> network = 0) {
  WifiNetworkDisconnectedEventBuilder builder_(_fbb);
  builder_.add_network(network);
  return builder_.Finish();
}

struct WifiNetworkDisconnectedEvent::Traits {
  using type = WifiNetworkDisconnectedEvent;
  static auto constexpr Create = CreateWifiNetworkDisconnectedEvent;
};

struct DeviceToLocalMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceToLocalMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.DeviceToLocalMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  OpenShock::Serialization::Local::DeviceToLocalMessagePayload payload_type() const {
    return static_cast<OpenShock::Serialization::Local::DeviceToLocalMessagePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const OpenShock::Serialization::Local::ReadyMessage *payload_as_ReadyMessage() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::ReadyMessage ? static_cast<const OpenShock::Serialization::Local::ReadyMessage *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::ErrorMessage *payload_as_ErrorMessage() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::ErrorMessage ? static_cast<const OpenShock::Serialization::Local::ErrorMessage *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiScanStatusMessage *payload_as_WifiScanStatusMessage() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiScanStatusMessage ? static_cast<const OpenShock::Serialization::Local::WifiScanStatusMessage *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkDiscoveredEvent *payload_as_WifiNetworkDiscoveredEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkDiscoveredEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkDiscoveredEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkUpdatedEvent *payload_as_WifiNetworkUpdatedEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkUpdatedEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkUpdatedEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkLostEvent *payload_as_WifiNetworkLostEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkLostEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkLostEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkSavedEvent *payload_as_WifiNetworkSavedEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkSavedEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkSavedEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkRemovedEvent *payload_as_WifiNetworkRemovedEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkRemovedEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkRemovedEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkConnectedEvent *payload_as_WifiNetworkConnectedEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkConnectedEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkConnectedEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkDisconnectedEvent *payload_as_WifiNetworkDisconnectedEvent() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::WifiNetworkDisconnectedEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkDisconnectedEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::GatewayPairCommandResult *payload_as_GatewayPairCommandResult() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::GatewayPairCommandResult ? static_cast<const OpenShock::Serialization::Local::GatewayPairCommandResult *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::SetRfTxPinCommandResult *payload_as_SetRfTxPinCommandResult() const {
    return payload_type() == OpenShock::Serialization::Local::DeviceToLocalMessagePayload::SetRfTxPinCommandResult ? static_cast<const OpenShock::Serialization::Local::SetRfTxPinCommandResult *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyDeviceToLocalMessagePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OpenShock::Serialization::Local::ReadyMessage *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::ReadyMessage>() const {
  return payload_as_ReadyMessage();
}

template<> inline const OpenShock::Serialization::Local::ErrorMessage *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::ErrorMessage>() const {
  return payload_as_ErrorMessage();
}

template<> inline const OpenShock::Serialization::Local::WifiScanStatusMessage *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiScanStatusMessage>() const {
  return payload_as_WifiScanStatusMessage();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkDiscoveredEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkDiscoveredEvent>() const {
  return payload_as_WifiNetworkDiscoveredEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkUpdatedEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkUpdatedEvent>() const {
  return payload_as_WifiNetworkUpdatedEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkLostEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkLostEvent>() const {
  return payload_as_WifiNetworkLostEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkSavedEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkSavedEvent>() const {
  return payload_as_WifiNetworkSavedEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkRemovedEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkRemovedEvent>() const {
  return payload_as_WifiNetworkRemovedEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkConnectedEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkConnectedEvent>() const {
  return payload_as_WifiNetworkConnectedEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkDisconnectedEvent *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkDisconnectedEvent>() const {
  return payload_as_WifiNetworkDisconnectedEvent();
}

template<> inline const OpenShock::Serialization::Local::GatewayPairCommandResult *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::GatewayPairCommandResult>() const {
  return payload_as_GatewayPairCommandResult();
}

template<> inline const OpenShock::Serialization::Local::SetRfTxPinCommandResult *DeviceToLocalMessage::payload_as<OpenShock::Serialization::Local::SetRfTxPinCommandResult>() const {
  return payload_as_SetRfTxPinCommandResult();
}

struct DeviceToLocalMessageBuilder {
  typedef DeviceToLocalMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(OpenShock::Serialization::Local::DeviceToLocalMessagePayload payload_type) {
    fbb_.AddElement<uint8_t>(DeviceToLocalMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(DeviceToLocalMessage::VT_PAYLOAD, payload);
  }
  explicit DeviceToLocalMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceToLocalMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceToLocalMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceToLocalMessage> CreateDeviceToLocalMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Local::DeviceToLocalMessagePayload payload_type = OpenShock::Serialization::Local::DeviceToLocalMessagePayload::NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  DeviceToLocalMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct DeviceToLocalMessage::Traits {
  using type = DeviceToLocalMessage;
  static auto constexpr Create = CreateDeviceToLocalMessage;
};

inline bool VerifyDeviceToLocalMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, DeviceToLocalMessagePayload type) {
  switch (type) {
    case DeviceToLocalMessagePayload::NONE: {
      return true;
    }
    case DeviceToLocalMessagePayload::ReadyMessage: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::ReadyMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::ErrorMessage: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::ErrorMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiScanStatusMessage: {
      return verifier.VerifyField<OpenShock::Serialization::Local::WifiScanStatusMessage>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case DeviceToLocalMessagePayload::WifiNetworkDiscoveredEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkDiscoveredEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiNetworkUpdatedEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkUpdatedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiNetworkLostEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkLostEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiNetworkSavedEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkSavedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiNetworkRemovedEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkRemovedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiNetworkConnectedEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkConnectedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::WifiNetworkDisconnectedEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkDisconnectedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToLocalMessagePayload::GatewayPairCommandResult: {
      return verifier.VerifyField<OpenShock::Serialization::Local::GatewayPairCommandResult>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case DeviceToLocalMessagePayload::SetRfTxPinCommandResult: {
      return verifier.VerifyField<OpenShock::Serialization::Local::SetRfTxPinCommandResult>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    default: return true;
  }
}

inline bool VerifyDeviceToLocalMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<DeviceToLocalMessagePayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDeviceToLocalMessagePayload(
        verifier,  values->Get(i), types->GetEnum<DeviceToLocalMessagePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const OpenShock::Serialization::Local::DeviceToLocalMessage *GetDeviceToLocalMessage(const void *buf) {
  return ::flatbuffers::GetRoot<OpenShock::Serialization::Local::DeviceToLocalMessage>(buf);
}

inline const OpenShock::Serialization::Local::DeviceToLocalMessage *GetSizePrefixedDeviceToLocalMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OpenShock::Serialization::Local::DeviceToLocalMessage>(buf);
}

inline bool VerifyDeviceToLocalMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OpenShock::Serialization::Local::DeviceToLocalMessage>(nullptr);
}

inline bool VerifySizePrefixedDeviceToLocalMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OpenShock::Serialization::Local::DeviceToLocalMessage>(nullptr);
}

inline void FinishDeviceToLocalMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::DeviceToLocalMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDeviceToLocalMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::DeviceToLocalMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Local
}  // namespace Serialization
}  // namespace OpenShock

#endif  // FLATBUFFERS_GENERATED_DEVICETOLOCALMESSAGE_OPENSHOCK_SERIALIZATION_LOCAL_H_
