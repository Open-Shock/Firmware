// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GATEWAYTOHUBMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_
#define FLATBUFFERS_GENERATED_GATEWAYTOHUBMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "SemVer_generated.h"
#include "ShockerCommandType_generated.h"
#include "ShockerModelType_generated.h"

namespace OpenShock {
namespace Serialization {
namespace Gateway {

struct Ping;
struct PingBuilder;

struct Trigger;
struct TriggerBuilder;

struct ShockerCommand;
struct ShockerCommandBuilder;

struct ShockerCommandList;
struct ShockerCommandListBuilder;

struct OtaUpdateRequest;
struct OtaUpdateRequestBuilder;

struct GatewayToHubMessage;
struct GatewayToHubMessageBuilder;

enum class TriggerType : uint8_t {
  /// Restart the hub
  Restart = 0,
  /// Trigger the emergency stop on the hub, this does however not allow for resetting it
  EmergencyStop = 1,
  /// Enable the captive portal
  CaptivePortalEnable = 2,
  /// Disable the captive portal
  CaptivePortalDisable = 3,
  MIN = Restart,
  MAX = CaptivePortalDisable
};

inline const TriggerType (&EnumValuesTriggerType())[4] {
  static const TriggerType values[] = {
    TriggerType::Restart,
    TriggerType::EmergencyStop,
    TriggerType::CaptivePortalEnable,
    TriggerType::CaptivePortalDisable
  };
  return values;
}

inline const char * const *EnumNamesTriggerType() {
  static const char * const names[5] = {
    "Restart",
    "EmergencyStop",
    "CaptivePortalEnable",
    "CaptivePortalDisable",
    nullptr
  };
  return names;
}

inline const char *EnumNameTriggerType(TriggerType e) {
  if (::flatbuffers::IsOutRange(e, TriggerType::Restart, TriggerType::CaptivePortalDisable)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTriggerType()[index];
}

enum class GatewayToHubMessagePayload : uint8_t {
  NONE = 0,
  /// Ping message, should immediately be responded to with a pong
  Ping = 1,
  /// Trigger a specific action on the hub
  Trigger = 2,
  /// Send a list of shocker commands to the hub
  ShockerCommandList = 3,
  /// Request an OTA update to be performed
  OtaUpdateRequest = 4,
  MIN = NONE,
  MAX = OtaUpdateRequest
};

inline const GatewayToHubMessagePayload (&EnumValuesGatewayToHubMessagePayload())[5] {
  static const GatewayToHubMessagePayload values[] = {
    GatewayToHubMessagePayload::NONE,
    GatewayToHubMessagePayload::Ping,
    GatewayToHubMessagePayload::Trigger,
    GatewayToHubMessagePayload::ShockerCommandList,
    GatewayToHubMessagePayload::OtaUpdateRequest
  };
  return values;
}

inline const char * const *EnumNamesGatewayToHubMessagePayload() {
  static const char * const names[6] = {
    "NONE",
    "Ping",
    "Trigger",
    "ShockerCommandList",
    "OtaUpdateRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameGatewayToHubMessagePayload(GatewayToHubMessagePayload e) {
  if (::flatbuffers::IsOutRange(e, GatewayToHubMessagePayload::NONE, GatewayToHubMessagePayload::OtaUpdateRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGatewayToHubMessagePayload()[index];
}

template<typename T> struct GatewayToHubMessagePayloadTraits {
  static const GatewayToHubMessagePayload enum_value = GatewayToHubMessagePayload::NONE;
};

template<> struct GatewayToHubMessagePayloadTraits<OpenShock::Serialization::Gateway::Ping> {
  static const GatewayToHubMessagePayload enum_value = GatewayToHubMessagePayload::Ping;
};

template<> struct GatewayToHubMessagePayloadTraits<OpenShock::Serialization::Gateway::Trigger> {
  static const GatewayToHubMessagePayload enum_value = GatewayToHubMessagePayload::Trigger;
};

template<> struct GatewayToHubMessagePayloadTraits<OpenShock::Serialization::Gateway::ShockerCommandList> {
  static const GatewayToHubMessagePayload enum_value = GatewayToHubMessagePayload::ShockerCommandList;
};

template<> struct GatewayToHubMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaUpdateRequest> {
  static const GatewayToHubMessagePayload enum_value = GatewayToHubMessagePayload::OtaUpdateRequest;
};

bool VerifyGatewayToHubMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, GatewayToHubMessagePayload type);
bool VerifyGatewayToHubMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<GatewayToHubMessagePayload> *types);

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.Ping";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIX_UTC_TIME = 4
  };
  uint64_t unix_utc_time() const {
    return GetField<uint64_t>(VT_UNIX_UTC_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UNIX_UTC_TIME, 8) &&
           verifier.EndTable();
  }
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unix_utc_time(uint64_t unix_utc_time) {
    fbb_.AddElement<uint64_t>(Ping::VT_UNIX_UTC_TIME, unix_utc_time, 0);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t unix_utc_time = 0) {
  PingBuilder builder_(_fbb);
  builder_.add_unix_utc_time(unix_utc_time);
  return builder_.Finish();
}

struct Ping::Traits {
  using type = Ping;
  static auto constexpr Create = CreatePing;
};

struct Trigger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriggerBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.Trigger";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  OpenShock::Serialization::Gateway::TriggerType type() const {
    return static_cast<OpenShock::Serialization::Gateway::TriggerType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct TriggerBuilder {
  typedef Trigger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(OpenShock::Serialization::Gateway::TriggerType type) {
    fbb_.AddElement<uint8_t>(Trigger::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit TriggerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Trigger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Trigger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Trigger> CreateTrigger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Gateway::TriggerType type = OpenShock::Serialization::Gateway::TriggerType::Restart) {
  TriggerBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Trigger::Traits {
  using type = Trigger;
  static auto constexpr Create = CreateTrigger;
};

struct ShockerCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShockerCommandBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.ShockerCommand";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL = 4,
    VT_ID = 6,
    VT_TYPE = 8,
    VT_INTENSITY = 10,
    VT_DURATION = 12
  };
  OpenShock::Serialization::Types::ShockerModelType model() const {
    return static_cast<OpenShock::Serialization::Types::ShockerModelType>(GetField<uint8_t>(VT_MODEL, 0));
  }
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  OpenShock::Serialization::Types::ShockerCommandType type() const {
    return static_cast<OpenShock::Serialization::Types::ShockerCommandType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint8_t intensity() const {
    return GetField<uint8_t>(VT_INTENSITY, 0);
  }
  uint16_t duration() const {
    return GetField<uint16_t>(VT_DURATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODEL, 1) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_INTENSITY, 1) &&
           VerifyField<uint16_t>(verifier, VT_DURATION, 2) &&
           verifier.EndTable();
  }
};

struct ShockerCommandBuilder {
  typedef ShockerCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model(OpenShock::Serialization::Types::ShockerModelType model) {
    fbb_.AddElement<uint8_t>(ShockerCommand::VT_MODEL, static_cast<uint8_t>(model), 0);
  }
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(ShockerCommand::VT_ID, id, 0);
  }
  void add_type(OpenShock::Serialization::Types::ShockerCommandType type) {
    fbb_.AddElement<uint8_t>(ShockerCommand::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_intensity(uint8_t intensity) {
    fbb_.AddElement<uint8_t>(ShockerCommand::VT_INTENSITY, intensity, 0);
  }
  void add_duration(uint16_t duration) {
    fbb_.AddElement<uint16_t>(ShockerCommand::VT_DURATION, duration, 0);
  }
  explicit ShockerCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShockerCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShockerCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShockerCommand> CreateShockerCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Types::ShockerModelType model = OpenShock::Serialization::Types::ShockerModelType::CaiXianlin,
    uint16_t id = 0,
    OpenShock::Serialization::Types::ShockerCommandType type = OpenShock::Serialization::Types::ShockerCommandType::Stop,
    uint8_t intensity = 0,
    uint16_t duration = 0) {
  ShockerCommandBuilder builder_(_fbb);
  builder_.add_duration(duration);
  builder_.add_id(id);
  builder_.add_intensity(intensity);
  builder_.add_type(type);
  builder_.add_model(model);
  return builder_.Finish();
}

struct ShockerCommand::Traits {
  using type = ShockerCommand;
  static auto constexpr Create = CreateShockerCommand;
};

struct ShockerCommandList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShockerCommandListBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.ShockerCommandList";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMANDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Gateway::ShockerCommand>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Gateway::ShockerCommand>> *>(VT_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct ShockerCommandListBuilder {
  typedef ShockerCommandList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Gateway::ShockerCommand>>> commands) {
    fbb_.AddOffset(ShockerCommandList::VT_COMMANDS, commands);
  }
  explicit ShockerCommandListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShockerCommandList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShockerCommandList>(end);
    fbb_.Required(o, ShockerCommandList::VT_COMMANDS);
    return o;
  }
};

inline ::flatbuffers::Offset<ShockerCommandList> CreateShockerCommandList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Gateway::ShockerCommand>>> commands = 0) {
  ShockerCommandListBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

struct ShockerCommandList::Traits {
  using type = ShockerCommandList;
  static auto constexpr Create = CreateShockerCommandList;
};

inline ::flatbuffers::Offset<ShockerCommandList> CreateShockerCommandListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<OpenShock::Serialization::Gateway::ShockerCommand>> *commands = nullptr) {
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<OpenShock::Serialization::Gateway::ShockerCommand>>(*commands) : 0;
  return OpenShock::Serialization::Gateway::CreateShockerCommandList(
      _fbb,
      commands__);
}

struct OtaUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaUpdateRequestBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaUpdateRequest";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  const OpenShock::Serialization::Types::SemVer *version() const {
    return GetPointer<const OpenShock::Serialization::Types::SemVer *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           verifier.EndTable();
  }
};

struct OtaUpdateRequestBuilder {
  typedef OtaUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> version) {
    fbb_.AddOffset(OtaUpdateRequest::VT_VERSION, version);
  }
  explicit OtaUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaUpdateRequest>(end);
    fbb_.Required(o, OtaUpdateRequest::VT_VERSION);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaUpdateRequest> CreateOtaUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> version = 0) {
  OtaUpdateRequestBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

struct OtaUpdateRequest::Traits {
  using type = OtaUpdateRequest;
  static auto constexpr Create = CreateOtaUpdateRequest;
};

struct GatewayToHubMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GatewayToHubMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.GatewayToHubMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  OpenShock::Serialization::Gateway::GatewayToHubMessagePayload payload_type() const {
    return static_cast<OpenShock::Serialization::Gateway::GatewayToHubMessagePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const OpenShock::Serialization::Gateway::Ping *payload_as_Ping() const {
    return payload_type() == OpenShock::Serialization::Gateway::GatewayToHubMessagePayload::Ping ? static_cast<const OpenShock::Serialization::Gateway::Ping *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::Trigger *payload_as_Trigger() const {
    return payload_type() == OpenShock::Serialization::Gateway::GatewayToHubMessagePayload::Trigger ? static_cast<const OpenShock::Serialization::Gateway::Trigger *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::ShockerCommandList *payload_as_ShockerCommandList() const {
    return payload_type() == OpenShock::Serialization::Gateway::GatewayToHubMessagePayload::ShockerCommandList ? static_cast<const OpenShock::Serialization::Gateway::ShockerCommandList *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaUpdateRequest *payload_as_OtaUpdateRequest() const {
    return payload_type() == OpenShock::Serialization::Gateway::GatewayToHubMessagePayload::OtaUpdateRequest ? static_cast<const OpenShock::Serialization::Gateway::OtaUpdateRequest *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           VerifyGatewayToHubMessagePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OpenShock::Serialization::Gateway::Ping *GatewayToHubMessage::payload_as<OpenShock::Serialization::Gateway::Ping>() const {
  return payload_as_Ping();
}

template<> inline const OpenShock::Serialization::Gateway::Trigger *GatewayToHubMessage::payload_as<OpenShock::Serialization::Gateway::Trigger>() const {
  return payload_as_Trigger();
}

template<> inline const OpenShock::Serialization::Gateway::ShockerCommandList *GatewayToHubMessage::payload_as<OpenShock::Serialization::Gateway::ShockerCommandList>() const {
  return payload_as_ShockerCommandList();
}

template<> inline const OpenShock::Serialization::Gateway::OtaUpdateRequest *GatewayToHubMessage::payload_as<OpenShock::Serialization::Gateway::OtaUpdateRequest>() const {
  return payload_as_OtaUpdateRequest();
}

struct GatewayToHubMessageBuilder {
  typedef GatewayToHubMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(OpenShock::Serialization::Gateway::GatewayToHubMessagePayload payload_type) {
    fbb_.AddElement<uint8_t>(GatewayToHubMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(GatewayToHubMessage::VT_PAYLOAD, payload);
  }
  explicit GatewayToHubMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatewayToHubMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatewayToHubMessage>(end);
    fbb_.Required(o, GatewayToHubMessage::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<GatewayToHubMessage> CreateGatewayToHubMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Gateway::GatewayToHubMessagePayload payload_type = OpenShock::Serialization::Gateway::GatewayToHubMessagePayload::NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  GatewayToHubMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct GatewayToHubMessage::Traits {
  using type = GatewayToHubMessage;
  static auto constexpr Create = CreateGatewayToHubMessage;
};

inline bool VerifyGatewayToHubMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, GatewayToHubMessagePayload type) {
  switch (type) {
    case GatewayToHubMessagePayload::NONE: {
      return true;
    }
    case GatewayToHubMessagePayload::Ping: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::Ping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GatewayToHubMessagePayload::Trigger: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::Trigger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GatewayToHubMessagePayload::ShockerCommandList: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::ShockerCommandList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GatewayToHubMessagePayload::OtaUpdateRequest: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGatewayToHubMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<GatewayToHubMessagePayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGatewayToHubMessagePayload(
        verifier,  values->Get(i), types->GetEnum<GatewayToHubMessagePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const OpenShock::Serialization::Gateway::GatewayToHubMessage *GetGatewayToHubMessage(const void *buf) {
  return ::flatbuffers::GetRoot<OpenShock::Serialization::Gateway::GatewayToHubMessage>(buf);
}

inline const OpenShock::Serialization::Gateway::GatewayToHubMessage *GetSizePrefixedGatewayToHubMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OpenShock::Serialization::Gateway::GatewayToHubMessage>(buf);
}

inline bool VerifyGatewayToHubMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OpenShock::Serialization::Gateway::GatewayToHubMessage>(nullptr);
}

inline bool VerifySizePrefixedGatewayToHubMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OpenShock::Serialization::Gateway::GatewayToHubMessage>(nullptr);
}

inline void FinishGatewayToHubMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Gateway::GatewayToHubMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGatewayToHubMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Gateway::GatewayToHubMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gateway
}  // namespace Serialization
}  // namespace OpenShock

#endif  // FLATBUFFERS_GENERATED_GATEWAYTOHUBMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_
