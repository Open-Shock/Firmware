// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HUBTOGATEWAYMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_
#define FLATBUFFERS_GENERATED_HUBTOGATEWAYMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "FirmwareBootType_generated.h"
#include "OtaUpdateProgressTask_generated.h"
#include "SemVer_generated.h"

namespace OpenShock {
namespace Serialization {
namespace Gateway {

struct Pong;
struct PongBuilder;

struct BootStatus;
struct BootStatusBuilder;

struct OtaUpdateStarted;
struct OtaUpdateStartedBuilder;

struct OtaUpdateProgress;
struct OtaUpdateProgressBuilder;

struct OtaUpdateFailed;
struct OtaUpdateFailedBuilder;

struct HubToGatewayMessage;
struct HubToGatewayMessageBuilder;

enum class HubToGatewayMessagePayload : uint8_t {
  NONE = 0,
  /// Respond to a ping message
  Pong = 1,
  /// Report the current boot status, used to report firmware version and OTA update results
  BootStatus = 2,
  /// Report that an OTA update has started
  OtaUpdateStarted = 3,
  /// Report the progress of an OTA update
  OtaUpdateProgress = 4,
  /// Report that an OTA update has failed
  OtaUpdateFailed = 5,
  MIN = NONE,
  MAX = OtaUpdateFailed
};

inline const HubToGatewayMessagePayload (&EnumValuesHubToGatewayMessagePayload())[6] {
  static const HubToGatewayMessagePayload values[] = {
    HubToGatewayMessagePayload::NONE,
    HubToGatewayMessagePayload::Pong,
    HubToGatewayMessagePayload::BootStatus,
    HubToGatewayMessagePayload::OtaUpdateStarted,
    HubToGatewayMessagePayload::OtaUpdateProgress,
    HubToGatewayMessagePayload::OtaUpdateFailed
  };
  return values;
}

inline const char * const *EnumNamesHubToGatewayMessagePayload() {
  static const char * const names[7] = {
    "NONE",
    "Pong",
    "BootStatus",
    "OtaUpdateStarted",
    "OtaUpdateProgress",
    "OtaUpdateFailed",
    nullptr
  };
  return names;
}

inline const char *EnumNameHubToGatewayMessagePayload(HubToGatewayMessagePayload e) {
  if (::flatbuffers::IsOutRange(e, HubToGatewayMessagePayload::NONE, HubToGatewayMessagePayload::OtaUpdateFailed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHubToGatewayMessagePayload()[index];
}

template<typename T> struct HubToGatewayMessagePayloadTraits {
  static const HubToGatewayMessagePayload enum_value = HubToGatewayMessagePayload::NONE;
};

template<> struct HubToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::Pong> {
  static const HubToGatewayMessagePayload enum_value = HubToGatewayMessagePayload::Pong;
};

template<> struct HubToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::BootStatus> {
  static const HubToGatewayMessagePayload enum_value = HubToGatewayMessagePayload::BootStatus;
};

template<> struct HubToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaUpdateStarted> {
  static const HubToGatewayMessagePayload enum_value = HubToGatewayMessagePayload::OtaUpdateStarted;
};

template<> struct HubToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaUpdateProgress> {
  static const HubToGatewayMessagePayload enum_value = HubToGatewayMessagePayload::OtaUpdateProgress;
};

template<> struct HubToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaUpdateFailed> {
  static const HubToGatewayMessagePayload enum_value = HubToGatewayMessagePayload::OtaUpdateFailed;
};

bool VerifyHubToGatewayMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, HubToGatewayMessagePayload type);
bool VerifyHubToGatewayMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<HubToGatewayMessagePayload> *types);

struct Pong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PongBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.Pong";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPTIME = 4,
    VT_RSSI = 6
  };
  uint64_t uptime() const {
    return GetField<uint64_t>(VT_UPTIME, 0);
  }
  int32_t rssi() const {
    return GetField<int32_t>(VT_RSSI, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME, 8) &&
           VerifyField<int32_t>(verifier, VT_RSSI, 4) &&
           verifier.EndTable();
  }
};

struct PongBuilder {
  typedef Pong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uptime(uint64_t uptime) {
    fbb_.AddElement<uint64_t>(Pong::VT_UPTIME, uptime, 0);
  }
  void add_rssi(int32_t rssi) {
    fbb_.AddElement<int32_t>(Pong::VT_RSSI, rssi, 0);
  }
  explicit PongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pong> CreatePong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uptime = 0,
    int32_t rssi = 0) {
  PongBuilder builder_(_fbb);
  builder_.add_uptime(uptime);
  builder_.add_rssi(rssi);
  return builder_.Finish();
}

struct Pong::Traits {
  using type = Pong;
  static auto constexpr Create = CreatePong;
};

struct BootStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BootStatusBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.BootStatus";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOT_TYPE = 4,
    VT_FIRMWARE_VERSION = 6,
    VT_OTA_UPDATE_ID = 8
  };
  OpenShock::Serialization::Types::FirmwareBootType boot_type() const {
    return static_cast<OpenShock::Serialization::Types::FirmwareBootType>(GetField<uint8_t>(VT_BOOT_TYPE, 0));
  }
  const OpenShock::Serialization::Types::SemVer *firmware_version() const {
    return GetPointer<const OpenShock::Serialization::Types::SemVer *>(VT_FIRMWARE_VERSION);
  }
  int32_t ota_update_id() const {
    return GetField<int32_t>(VT_OTA_UPDATE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyTable(firmware_version()) &&
           VerifyField<int32_t>(verifier, VT_OTA_UPDATE_ID, 4) &&
           verifier.EndTable();
  }
};

struct BootStatusBuilder {
  typedef BootStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_boot_type(OpenShock::Serialization::Types::FirmwareBootType boot_type) {
    fbb_.AddElement<uint8_t>(BootStatus::VT_BOOT_TYPE, static_cast<uint8_t>(boot_type), 0);
  }
  void add_firmware_version(::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> firmware_version) {
    fbb_.AddOffset(BootStatus::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_ota_update_id(int32_t ota_update_id) {
    fbb_.AddElement<int32_t>(BootStatus::VT_OTA_UPDATE_ID, ota_update_id, 0);
  }
  explicit BootStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BootStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BootStatus>(end);
    fbb_.Required(o, BootStatus::VT_FIRMWARE_VERSION);
    return o;
  }
};

inline ::flatbuffers::Offset<BootStatus> CreateBootStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Types::FirmwareBootType boot_type = OpenShock::Serialization::Types::FirmwareBootType::Normal,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> firmware_version = 0,
    int32_t ota_update_id = 0) {
  BootStatusBuilder builder_(_fbb);
  builder_.add_ota_update_id(ota_update_id);
  builder_.add_firmware_version(firmware_version);
  builder_.add_boot_type(boot_type);
  return builder_.Finish();
}

struct BootStatus::Traits {
  using type = BootStatus;
  static auto constexpr Create = CreateBootStatus;
};

struct OtaUpdateStarted FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaUpdateStartedBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaUpdateStarted";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_VERSION = 6
  };
  int32_t update_id() const {
    return GetField<int32_t>(VT_UPDATE_ID, 0);
  }
  const OpenShock::Serialization::Types::SemVer *version() const {
    return GetPointer<const OpenShock::Serialization::Types::SemVer *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_ID, 4) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           verifier.EndTable();
  }
};

struct OtaUpdateStartedBuilder {
  typedef OtaUpdateStarted Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(int32_t update_id) {
    fbb_.AddElement<int32_t>(OtaUpdateStarted::VT_UPDATE_ID, update_id, 0);
  }
  void add_version(::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> version) {
    fbb_.AddOffset(OtaUpdateStarted::VT_VERSION, version);
  }
  explicit OtaUpdateStartedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaUpdateStarted> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaUpdateStarted>(end);
    fbb_.Required(o, OtaUpdateStarted::VT_VERSION);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaUpdateStarted> CreateOtaUpdateStarted(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> version = 0) {
  OtaUpdateStartedBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_update_id(update_id);
  return builder_.Finish();
}

struct OtaUpdateStarted::Traits {
  using type = OtaUpdateStarted;
  static auto constexpr Create = CreateOtaUpdateStarted;
};

struct OtaUpdateProgress FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaUpdateProgressBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaUpdateProgress";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_TASK = 6,
    VT_PROGRESS = 8
  };
  int32_t update_id() const {
    return GetField<int32_t>(VT_UPDATE_ID, 0);
  }
  OpenShock::Serialization::Types::OtaUpdateProgressTask task() const {
    return static_cast<OpenShock::Serialization::Types::OtaUpdateProgressTask>(GetField<uint8_t>(VT_TASK, 0));
  }
  float progress() const {
    return GetField<float>(VT_PROGRESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_TASK, 1) &&
           VerifyField<float>(verifier, VT_PROGRESS, 4) &&
           verifier.EndTable();
  }
};

struct OtaUpdateProgressBuilder {
  typedef OtaUpdateProgress Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(int32_t update_id) {
    fbb_.AddElement<int32_t>(OtaUpdateProgress::VT_UPDATE_ID, update_id, 0);
  }
  void add_task(OpenShock::Serialization::Types::OtaUpdateProgressTask task) {
    fbb_.AddElement<uint8_t>(OtaUpdateProgress::VT_TASK, static_cast<uint8_t>(task), 0);
  }
  void add_progress(float progress) {
    fbb_.AddElement<float>(OtaUpdateProgress::VT_PROGRESS, progress, 0.0f);
  }
  explicit OtaUpdateProgressBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaUpdateProgress> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaUpdateProgress>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaUpdateProgress> CreateOtaUpdateProgress(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    OpenShock::Serialization::Types::OtaUpdateProgressTask task = OpenShock::Serialization::Types::OtaUpdateProgressTask::FetchingMetadata,
    float progress = 0.0f) {
  OtaUpdateProgressBuilder builder_(_fbb);
  builder_.add_progress(progress);
  builder_.add_update_id(update_id);
  builder_.add_task(task);
  return builder_.Finish();
}

struct OtaUpdateProgress::Traits {
  using type = OtaUpdateProgress;
  static auto constexpr Create = CreateOtaUpdateProgress;
};

struct OtaUpdateFailed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaUpdateFailedBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaUpdateFailed";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_MESSAGE = 6,
    VT_FATAL = 8
  };
  int32_t update_id() const {
    return GetField<int32_t>(VT_UPDATE_ID, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool fatal() const {
    return GetField<uint8_t>(VT_FATAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_ID, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint8_t>(verifier, VT_FATAL, 1) &&
           verifier.EndTable();
  }
};

struct OtaUpdateFailedBuilder {
  typedef OtaUpdateFailed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(int32_t update_id) {
    fbb_.AddElement<int32_t>(OtaUpdateFailed::VT_UPDATE_ID, update_id, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(OtaUpdateFailed::VT_MESSAGE, message);
  }
  void add_fatal(bool fatal) {
    fbb_.AddElement<uint8_t>(OtaUpdateFailed::VT_FATAL, static_cast<uint8_t>(fatal), 0);
  }
  explicit OtaUpdateFailedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaUpdateFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaUpdateFailed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaUpdateFailed> CreateOtaUpdateFailed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    bool fatal = false) {
  OtaUpdateFailedBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_update_id(update_id);
  builder_.add_fatal(fatal);
  return builder_.Finish();
}

struct OtaUpdateFailed::Traits {
  using type = OtaUpdateFailed;
  static auto constexpr Create = CreateOtaUpdateFailed;
};

inline ::flatbuffers::Offset<OtaUpdateFailed> CreateOtaUpdateFailedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    const char *message = nullptr,
    bool fatal = false) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return OpenShock::Serialization::Gateway::CreateOtaUpdateFailed(
      _fbb,
      update_id,
      message__,
      fatal);
}

struct HubToGatewayMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HubToGatewayMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.HubToGatewayMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  OpenShock::Serialization::Gateway::HubToGatewayMessagePayload payload_type() const {
    return static_cast<OpenShock::Serialization::Gateway::HubToGatewayMessagePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const OpenShock::Serialization::Gateway::Pong *payload_as_Pong() const {
    return payload_type() == OpenShock::Serialization::Gateway::HubToGatewayMessagePayload::Pong ? static_cast<const OpenShock::Serialization::Gateway::Pong *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::BootStatus *payload_as_BootStatus() const {
    return payload_type() == OpenShock::Serialization::Gateway::HubToGatewayMessagePayload::BootStatus ? static_cast<const OpenShock::Serialization::Gateway::BootStatus *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaUpdateStarted *payload_as_OtaUpdateStarted() const {
    return payload_type() == OpenShock::Serialization::Gateway::HubToGatewayMessagePayload::OtaUpdateStarted ? static_cast<const OpenShock::Serialization::Gateway::OtaUpdateStarted *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaUpdateProgress *payload_as_OtaUpdateProgress() const {
    return payload_type() == OpenShock::Serialization::Gateway::HubToGatewayMessagePayload::OtaUpdateProgress ? static_cast<const OpenShock::Serialization::Gateway::OtaUpdateProgress *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaUpdateFailed *payload_as_OtaUpdateFailed() const {
    return payload_type() == OpenShock::Serialization::Gateway::HubToGatewayMessagePayload::OtaUpdateFailed ? static_cast<const OpenShock::Serialization::Gateway::OtaUpdateFailed *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           VerifyHubToGatewayMessagePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OpenShock::Serialization::Gateway::Pong *HubToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::Pong>() const {
  return payload_as_Pong();
}

template<> inline const OpenShock::Serialization::Gateway::BootStatus *HubToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::BootStatus>() const {
  return payload_as_BootStatus();
}

template<> inline const OpenShock::Serialization::Gateway::OtaUpdateStarted *HubToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::OtaUpdateStarted>() const {
  return payload_as_OtaUpdateStarted();
}

template<> inline const OpenShock::Serialization::Gateway::OtaUpdateProgress *HubToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::OtaUpdateProgress>() const {
  return payload_as_OtaUpdateProgress();
}

template<> inline const OpenShock::Serialization::Gateway::OtaUpdateFailed *HubToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::OtaUpdateFailed>() const {
  return payload_as_OtaUpdateFailed();
}

struct HubToGatewayMessageBuilder {
  typedef HubToGatewayMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(OpenShock::Serialization::Gateway::HubToGatewayMessagePayload payload_type) {
    fbb_.AddElement<uint8_t>(HubToGatewayMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(HubToGatewayMessage::VT_PAYLOAD, payload);
  }
  explicit HubToGatewayMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HubToGatewayMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HubToGatewayMessage>(end);
    fbb_.Required(o, HubToGatewayMessage::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<HubToGatewayMessage> CreateHubToGatewayMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Gateway::HubToGatewayMessagePayload payload_type = OpenShock::Serialization::Gateway::HubToGatewayMessagePayload::NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  HubToGatewayMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct HubToGatewayMessage::Traits {
  using type = HubToGatewayMessage;
  static auto constexpr Create = CreateHubToGatewayMessage;
};

inline bool VerifyHubToGatewayMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, HubToGatewayMessagePayload type) {
  switch (type) {
    case HubToGatewayMessagePayload::NONE: {
      return true;
    }
    case HubToGatewayMessagePayload::Pong: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::Pong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToGatewayMessagePayload::BootStatus: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::BootStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToGatewayMessagePayload::OtaUpdateStarted: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaUpdateStarted *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToGatewayMessagePayload::OtaUpdateProgress: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaUpdateProgress *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToGatewayMessagePayload::OtaUpdateFailed: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaUpdateFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHubToGatewayMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<HubToGatewayMessagePayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHubToGatewayMessagePayload(
        verifier,  values->Get(i), types->GetEnum<HubToGatewayMessagePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const OpenShock::Serialization::Gateway::HubToGatewayMessage *GetHubToGatewayMessage(const void *buf) {
  return ::flatbuffers::GetRoot<OpenShock::Serialization::Gateway::HubToGatewayMessage>(buf);
}

inline const OpenShock::Serialization::Gateway::HubToGatewayMessage *GetSizePrefixedHubToGatewayMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OpenShock::Serialization::Gateway::HubToGatewayMessage>(buf);
}

inline bool VerifyHubToGatewayMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OpenShock::Serialization::Gateway::HubToGatewayMessage>(nullptr);
}

inline bool VerifySizePrefixedHubToGatewayMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OpenShock::Serialization::Gateway::HubToGatewayMessage>(nullptr);
}

inline void FinishHubToGatewayMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Gateway::HubToGatewayMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedHubToGatewayMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Gateway::HubToGatewayMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gateway
}  // namespace Serialization
}  // namespace OpenShock

#endif  // FLATBUFFERS_GENERATED_HUBTOGATEWAYMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_
